[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Data 100 Debugging Guide",
    "section": "",
    "text": "About\nThis text offers pointers for keyboard shortcuts or common mistakes that accompany the coursework in the Spring 2024 Edition of the UC Berkeley course Data 100: Principles and Techniques of Data Science.\nInspiration for this guide was taken from the UC San Diego course DSC 10: Principles of Data Science and their debugging guide.\nIf you spot any typos or would like to suggest any changes, please fill out the Data 100 Content Feedback Form (Spring 2024). Note that this link will only work if you have an @berkeley.edu email address. If you’re not a student at Berkeley and would like to provide feedback, please email us at data100.instructors@berkeley.edu"
  },
  {
    "objectID": "jupyter101/jupyter101.html#shortcuts-for-cells",
    "href": "jupyter101/jupyter101.html#shortcuts-for-cells",
    "title": "Jupyter 101",
    "section": "Shortcuts for Cells",
    "text": "Shortcuts for Cells\nFor the following commands, make sure you’re in command mode. You can enter this mode by pressing esc.\n\na: create a cell above\nb: create a cell below\ndd: delete current cell\nm: convert a cell to markdown (text cell)\ny: convert a cell to code"
  },
  {
    "objectID": "jupyter101/jupyter101.html#running-cells",
    "href": "jupyter101/jupyter101.html#running-cells",
    "title": "Jupyter 101",
    "section": "Running Cells",
    "text": "Running Cells\nFor individual cells,\n\nctrl + return: run the current cell\nshift + return: run the current cell and move to the next cell\n\nTo run all cells in a notebook:\n\nIn the menu bar on the left, click Run. From here, you have several options. The ones we use most commonly are:\n\nRun All Above Selected Cell: this runs every cell above the selected cell\nRun Selected Cell and All Below: this runs the selected cell and all cells below\nRun All: this runs every cell in the notebook from top-to-bottom"
  },
  {
    "objectID": "jupyter101/jupyter101.html#saving-your-notebook",
    "href": "jupyter101/jupyter101.html#saving-your-notebook",
    "title": "Jupyter 101",
    "section": "Saving your notebook",
    "text": "Saving your notebook\nJupyter autosaves your work, but there can be a delay. As such, it’s a good idea to save your work as often as you remember and especially before submitting assignments. To do so, press ctrl + s."
  },
  {
    "objectID": "jupyter101/jupyter101.html#restarting-kernel",
    "href": "jupyter101/jupyter101.html#restarting-kernel",
    "title": "Jupyter 101",
    "section": "Restarting Kernel",
    "text": "Restarting Kernel\nIn the menu bar on the left, click Kernel. From here, you have several options. The ones we use most commonly are:\n\nRestart Kernel...\nRestart Kernel and Run up to Selected Cell\nRestart Kernel and Run All Cells"
  },
  {
    "objectID": "jupyter_datahub/jupyter_datahub.html#my-kernel-died-restarted-or-is-very-slow",
    "href": "jupyter_datahub/jupyter_datahub.html#my-kernel-died-restarted-or-is-very-slow",
    "title": "Jupyter / Datahub",
    "section": "My kernel died, restarted, or is very slow",
    "text": "My kernel died, restarted, or is very slow\nJupyterhub connects you to an external container to run your code. That connection could be slow/severed because:\n\nyou haven’t made any changes to the notebook for a while\na cell took too much time to run\na cell took up too many resources to compute\n\nWhen you see a message like this:\n\n\n\n\nEither press the “Ok” button or reload the page\nRestart your kernel\nRerun your cells\n\nNote that you may loose some recent work if your kernel restarted when you were in the middle of editing a cell. As such, we recommend saving your work as often as possible.\nIf this does not fix the issue, it could be a problem with your code, usually the last cell that executed before your kernel crashed. Double check your logic, and feel free to make a private post on Ed if you’re stuck!"
  },
  {
    "objectID": "jupyter_datahub/jupyter_datahub.html#i-cant-edit-a-cell",
    "href": "jupyter_datahub/jupyter_datahub.html#i-cant-edit-a-cell",
    "title": "Jupyter / Datahub",
    "section": "I can’t edit a cell",
    "text": "I can’t edit a cell\nWe set some cells to read-only mode prevent accidental modification. To make the cell writeable,\n\nClick the cell\nClick setting on the top right corner\nUnder “Common Tools”, you can toggle between “Editable” (can edit the cell) and “Read-Only” (cannot edit the cell)"
  },
  {
    "objectID": "jupyter_datahub/jupyter_datahub.html#my-text-cell-looks-like-code",
    "href": "jupyter_datahub/jupyter_datahub.html#my-text-cell-looks-like-code",
    "title": "Jupyter / Datahub",
    "section": "My text cell looks like code",
    "text": "My text cell looks like code\nIf you double-click on a text (markdown) cell, it’ll appear in its raw format. To fix this, simply run the cell. If this doesn’t fix the problem, check out the commonly asked question below."
  },
  {
    "objectID": "jupyter_datahub/jupyter_datahub.html#my-text-cell-changed-to-a-code-cell-my-code-cell-changed-to-a-text-cell",
    "href": "jupyter_datahub/jupyter_datahub.html#my-text-cell-changed-to-a-code-cell-my-code-cell-changed-to-a-text-cell",
    "title": "Jupyter / Datahub",
    "section": "My text cell changed to a code cell / My code cell changed to a text cell",
    "text": "My text cell changed to a code cell / My code cell changed to a text cell\nSometimes, a text (markdown) cell was changed to a code cell, or a code cell can’t be run because it’s been changed to a text (markdown) or raw cell. To fix this, toggle the desired cell type in the top bar."
  },
  {
    "objectID": "jupyter_datahub/jupyter_datahub.html#why-does-running-a-particular-cell-cause-my-kernel-to-die",
    "href": "jupyter_datahub/jupyter_datahub.html#why-does-running-a-particular-cell-cause-my-kernel-to-die",
    "title": "Jupyter / Datahub",
    "section": "Why does running a particular cell cause my kernel to die?",
    "text": "Why does running a particular cell cause my kernel to die?\nIf one particular cell seems to cause your kernel to die, this is likely because the computer is trying to use more memory than it has available. For instance: your code is trying to create a gigantic array. To prevent the entire server from crashing, the kernel will “die”. This is an indication that there is a mistake in your code that you need to fix.\n\nI accidentally deleted something in a cell that was provided to me – how do I get it back?\nSuppose you’re working on Lab 5. One solution is to go directly to DataHub and rename your lab05 folder to something else, like lab05-old. Then, click the Lab 5 link on the course website again, and it’ll bring you to a brand-new version of Lab 5. You can then copy your work from your old Lab 5 to this new one, which should have the original version of the assignment.\nAlternatively, you can access this public repo and navigate to a blank copy of the assignment you were working on. In the case of Lab 5 for example, the notebook would be located at lab/lab05/lab05.ipynb. You can then check and copy over the contents of the deleted cell into a new cell in your existing notebook."
  },
  {
    "objectID": "jupyter_datahub/jupyter_datahub.html#click-here-to-download-zip-file-is-not-working",
    "href": "jupyter_datahub/jupyter_datahub.html#click-here-to-download-zip-file-is-not-working",
    "title": "Jupyter / Datahub",
    "section": "“Click here to download zip file” is not working",
    "text": "“Click here to download zip file” is not working\nWhen this happens, you can download the zip file through the menu on the left.\n\n\n\nRight click on the generated zip file and click “Download”."
  },
  {
    "objectID": "jupyter_datahub/jupyter_datahub.html#i-cant-export-my-assignment-as-a-pdf-due-to-a-latexfailed-error",
    "href": "jupyter_datahub/jupyter_datahub.html#i-cant-export-my-assignment-as-a-pdf-due-to-a-latexfailed-error",
    "title": "Jupyter / Datahub",
    "section": "I can’t export my assignment as a PDF due to a LatexFailed error",
    "text": "I can’t export my assignment as a PDF due to a LatexFailed error\nOccasionally when running the grader.export(run_tests=True) cell at the end of the notebook, you run into an error where the PDF failed to generate:\n\n\n\nConverting a Jupyter notebook to a PDF involves formatting some of the markdown text in LaTeX. However, this process will fail if your free response answers have (unresolved) LaTeX characters like \\n, $, or $$. If you’re short on time, your best bet is to take screenshots of your free response answers and submit them to Gradescope. If you have more time and would like the Datahub-generated PDF, please remove any special LaTeX characters from your free response answers."
  },
  {
    "objectID": "autograder_gradescope/autograder_gradescope.html#autograder",
    "href": "autograder_gradescope/autograder_gradescope.html#autograder",
    "title": "Autograder and Gradescope",
    "section": "Autograder",
    "text": "Autograder\n\nUnderstanding autograder error messages\nWhen you pass a test, you’ll see a nice, concise message and a cute emoji!\n\n\n\nWhen you don’t, however, the message can be a little confusing.\n\n\n\n\nThe best course of action is to find the test case that failed and use that as a starting point to debug your code.\n\n\n\n\n\nWhy do I get an error saying “grader is not defined”?\nIf it has been a while since you’ve worked on an assignment, the kernel will shut itself down to preserve memory. When this happens, all of your variables are forgotten, including the grader. That’s OK. The easiest way to fix this is by restarting your kernel and rerunning all the cells. To do this, in the top left menu, click Kernel -&gt; Restart and Run All Cells.\n\n\nI’m positive I have the right answer, but the test fails. Is there a mistake in the test?\nWhile you might see the correct answer displayed as the result of the cell, chances are your solution isn’t being stored in the answer variable. Make sure you are assigning the result to the answer variable and that there are no typos in the variable name. Finally, restart your kernel and run all the cells in order: Kernel -&gt; Restart and Run All Cells.\n\n\nWhy does grader.export(run_tests=True) fail if all previous tests passed?\nThis can happen if you “overwrite” a variable that is used in a question. For instance, say Question 1 asks you to store your answer in a variable named stat and, later on in the notebook, you change the value of stat; the test right after Question 1 will pass, but the test at the end of the notebook will fail. It is good programming practice to give your variables informative names and to avoid repeating the same variable name for more than one purpose.\n\n\nWhy does a notebook test fail now when it passed before, and I didn’t change my code?\nYou probably ran your notebook out of order. Re-run all previous cells in order, which is how your code will be graded."
  },
  {
    "objectID": "autograder_gradescope/autograder_gradescope.html#gradescope",
    "href": "autograder_gradescope/autograder_gradescope.html#gradescope",
    "title": "Autograder and Gradescope",
    "section": "Gradescope",
    "text": "Gradescope\nWhen submitting to Gradescope, there are often unexpected errors that make students lose more points than expected. Thus, it is imperative that you stay on the submission page until the autograder finishes running, and the results are displayed.\n\nWhy did a Gradescope test fail when all the Jupyter notebook’s tests passed?\nThis can happen if you’re running your notebook’s cells out of order. The autograder runs your notebook from top-to-bottom. If you’re defining a variable at the bottom of your notebook and using it at the top, the Gradescope autograder will fail because it doesn’t recognize the variable when it encounters it.\nThis is why we recommend going into the top left menu and clicking Kernel -&gt; Restart -&gt; Run All. The autograder “forgets” all of the variables and runs the notebook from top-to-bottom like the Gradescope autograder does. This will highlight any issues.\nFind the first cell that raises an error. Make sure that all of the variables used in that cell have been defined above that cell, and not below.\n\n\nWhy do I get a NameError: name ___ is not defined when I run a grader check?\nThis happens when you try to access a variable that has not been defined yet. Since the autograder runs all the cells in-order, if you happened to define a variable in a cell further down and accessed it before that cell, the autograder will likely throw this error. Another reason this could occur is because the notebook was not saved before the autograder tests are run. When in doubt, it is good practice to restart your kernel, run all the cells again, and save the notebook before running the cell that causes this error.\n\n\nMy autograder keeps running/timed out\nIf your Gradescope submission page has been stuck running on this page for a while:\n\n\n\nor if it times out:\n\n\n\nit means that the Gradescope autograder failed to execute in the expected amount of time. This could be due to an inefficiency in your code or a problem on Gradescope’s end, so we recommend resubmitting and letting the autograder rerun. It is your responsibility to ensure that the autograder runs properly, and, if it still fails, to follow up by making a private Ed post."
  },
  {
    "objectID": "pandas/pandas.html#understanding-pandas-errors",
    "href": "pandas/pandas.html#understanding-pandas-errors",
    "title": "Pandas",
    "section": "Understanding pandas errors",
    "text": "Understanding pandas errors\npandas errors can look red, scary, and very long. Fortunately, we don’t need to understand the entire thing! The most important parts of an error message are at the top, which tells you which line of code is causing the issue, and at the bottom, which tells you exactly what the error message is.\n\n\n\n\nThis note is (mostly) structured around the error messages that show up at the bottom."
  },
  {
    "objectID": "pandas/pandas.html#my-code-is-taking-a-really-long-time-to-run",
    "href": "pandas/pandas.html#my-code-is-taking-a-really-long-time-to-run",
    "title": "Pandas",
    "section": "My code is taking a really long time to run",
    "text": "My code is taking a really long time to run\nIt is normal for a cell to take a few seconds – sometimes a few minutes – to run. If it’s is taking too long, however, you have several options:\n\nTry restarting the kernel. Sometimes, Datahub glitches or lags, causing the code to run slower than expected. Restarting the kernel should fix this problem, but if the cell is still taking a while to run, it is likely a problem with your code.\nScrutinize your code. Am I using too many for loops? Is there a repeated operation that I can substitute with a pandas function?"
  },
  {
    "objectID": "pandas/pandas.html#why-is-it-generally-better-avoid-using-loops-or-list-comprehensions-when-possible",
    "href": "pandas/pandas.html#why-is-it-generally-better-avoid-using-loops-or-list-comprehensions-when-possible",
    "title": "Pandas",
    "section": "Why is it generally better avoid using loops or list comprehensions when possible?",
    "text": "Why is it generally better avoid using loops or list comprehensions when possible?\nIn one word: performance. NumPy and pandas functions are optimized to handle large amounts of data in an efficient manner. Even for simple operations, like the elementwise addition of two arrays, NumPy arrays are much faster and scale better (feel free to experiment with this yourself using %%time). This is why we encourage you to vectorize your code (ie. using NumPy arrays, Series, or DataFrames instead of Python lists) and use in-built NumPy/pandas functions wherever possible."
  },
  {
    "objectID": "pandas/pandas.html#keyerrors",
    "href": "pandas/pandas.html#keyerrors",
    "title": "Pandas",
    "section": "KeyErrors",
    "text": "KeyErrors\n\nKeyError: 'column_name'\nThis error usually happens when we have a DataFame called df, and we’re trying to do an operation on a column 'column_name' that does not exist. If you encounter this error, double check that you’re operating on the right column. It might be a good idea to display df and see what it looks like. You could also call df.columns to list all the columns in df."
  },
  {
    "objectID": "pandas/pandas.html#typeerrors",
    "href": "pandas/pandas.html#typeerrors",
    "title": "Pandas",
    "section": "TypeErrors",
    "text": "TypeErrors\n\nTypeError: '___' object is not callable\nThis often happens when you use a default keyword (like str, list, range, sum, or max) as a variable name, for instance:\nsum = 1 + 2 + 3\nThese errors can be tricky because they don’t error on their own but cause problems when we try to use the name sum (for example) later on in the notebook.\nTo fix the issue, identify any such lines of code, change your variable names to be something more informative, and restart your notebook.\nPython keywords like str and list appear in green text, so be on the lookout if any of your variable names appear in green!\n\n\nTypeError: could not convert string to a float\nThis error often occurs when we try to do math operations (ie. sum, average, min, max) on a DataFrame column or Series that contains strings instead of numbers (note that we can do math operations with booleans; Python treats True as 1 and False as 0).\nDouble check that the column you’re interested in is a numerical type (int, float, or double). If it looks like a number, but you’re still getting this error, you can use .astype(...) (documentation) to change the datatype of a DataFrame or Series.\n\n\nTypeError: Could not convert &lt;string&gt; to numeric\nRelated to the above (but distinct), you may run into this error when performing a numeric aggregation function (like mean or sum functions that take integer arguments) after doing a groupby operation on a DataFrame with non-numeric columns.\nWorking with the elections dataset for example,\nelections.groupby('Year').agg('mean')\nwould error because pandas cannot compute the mean of the names of presidents. There are two ways to get around this:\n\nSelect only the numeric columns you are interested in before applying the aggregation function. In the above case, both elections.groupby('Year')['Popular Vote'] or elections['Popular vote'].groupby('Year') would work.\nSetting the numeric_only argument to True in the .agg call, thereby applying the aggregation function only to numeric columns. For example, elections.groupby('Year').agg('mean', numeric_only=True).\n\n\n\nTypeError: 'NoneType' object is not subscriptable / AttributeError: 'NoneType' object has no attribute 'shape'\nThis usually occurs as you assign a None value to a variable, then try to either index into or access some attribute of that variable. For Python functions like append and extend, you do not need to do any variable assignment because they mutate the variable directly and return None. Assigning None tends to happen as a result of code like:\nsome_list = some_list.append(element)\nIn contrast, an operation like np.append does not mutate the variable in place and, instead, returns a copy. In these cases, (re)assignment is necessary:\nsome_array = np.append(some_array, element)\n\n\nTypeError: 'int'/'float' object is not subscriptable\nThis occurs when you try and index into an integer or other numeric Python data type. It can be confusing to debug amidst a muddle of code, but you can use the error message to identify which variable is causing this error. Using type(var_name) to check the data type of the variable in question can be a good starting point."
  },
  {
    "objectID": "pandas/pandas.html#indexerrors",
    "href": "pandas/pandas.html#indexerrors",
    "title": "Pandas",
    "section": "IndexErrors",
    "text": "IndexErrors\n\nIndexError: invalid index to scalar variable.\nThis error is similar to the last TypeError in the previous section. However, it is slightly different in that scalar variables come up in the context of NumPy data types which have slightly different attributes.\nFor a concrete example, if you defined\nnumpy_arr = np.array([1])\nand indexed into it twice (numpy_arr[0][0]), you would get the above error. Unlike a Python integer whose type is int, type(numpy_arr[0]) returns the NumPy version of an integer, numpy.int64. Additionally, you can check the data type by accessing the .dtype attribute of NumPy array (numpy_arr.dtype) or scalar variable (numpy_arr[0].dtype).\n\n\nIndexError: index _ is out of bounds for axis _ with size _\nThis error usually happens when you try to index a value that’s greater than the size of the array/list/DataFrame/Series. For example,\nsome_list = [2, 4, 6, 8]\nsome_list has a length of 4. Trying some_list[6] will error because index 6 is greater than the length of the array. Note that some_list[4] will also cause an IndexError because Python and pandas uses zero indexing, which means that the first element has index 0, the second element has index 1, etc.; some_list[4] would grab the fifth element, which is impossible when the list only has 4 elements."
  },
  {
    "objectID": "pandas/pandas.html#valueerrors",
    "href": "pandas/pandas.html#valueerrors",
    "title": "Pandas",
    "section": "ValueErrors",
    "text": "ValueErrors\n\nValueError: Truth value of a Series is ambiguous\nThis error occurs when you apply Python logical operators (or, and, not), which only operate on a single boolean values, to NumPy arrays or Series objects, which can contain multiple values. The fix is to use bitwise operators |, &, ~ , respectively, to allow for element-wise comparisons between values in arrays or Series.\n\n\nValueError: Can only compare identically-labeled Series objects\nAs the message would suggest, this error occurs when comparing two Series objects that have different lengths. You can double check the lengths of the Series using len(series_name) or series_name.size.\n\n\nValueError: -1 is not in range / KeyError: -1\nThis error occurs when you try and index into a Series or DataFrame as you would a Python list. Unlike a list where passing an index of -1 gives the last element, pandas interprets df[-1] as an attempt to find the row corresponding to index -1 (that is, df.loc[-1]). If your intention is to pick out the last row in df, consider using integer-position based indexing by doing df.iloc[-1]. In general, to avoid ambiguity in these cases, it is also good practice to write out both the row and column indices you want with df.iloc[-1, :]."
  }
]