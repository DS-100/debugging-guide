<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.545">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Pandas</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="pandas_files/libs/clipboard/clipboard.min.js"></script>
<script src="pandas_files/libs/quarto-html/quarto.js"></script>
<script src="pandas_files/libs/quarto-html/popper.min.js"></script>
<script src="pandas_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="pandas_files/libs/quarto-html/anchor.min.js"></script>
<link href="pandas_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="pandas_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="pandas_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="pandas_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="pandas_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#understanding-pandas-errors" id="toc-understanding-pandas-errors" class="nav-link active" data-scroll-target="#understanding-pandas-errors">Understanding <code>pandas</code> errors</a></li>
  <li><a href="#my-code-is-taking-a-really-long-time-to-run" id="toc-my-code-is-taking-a-really-long-time-to-run" class="nav-link" data-scroll-target="#my-code-is-taking-a-really-long-time-to-run">My code is taking a really long time to run</a></li>
  <li><a href="#why-is-it-generally-better-avoid-using-loops-or-list-comprehensions-when-possible" id="toc-why-is-it-generally-better-avoid-using-loops-or-list-comprehensions-when-possible" class="nav-link" data-scroll-target="#why-is-it-generally-better-avoid-using-loops-or-list-comprehensions-when-possible">Why is it generally better avoid using loops or list comprehensions when possible?</a></li>
  <li><a href="#keyerrors" id="toc-keyerrors" class="nav-link" data-scroll-target="#keyerrors">KeyErrors</a>
  <ul>
  <li><a href="#keyerror-column_name" id="toc-keyerror-column_name" class="nav-link" data-scroll-target="#keyerror-column_name"><code>KeyError: 'column_name'</code></a></li>
  </ul></li>
  <li><a href="#typeerrors" id="toc-typeerrors" class="nav-link" data-scroll-target="#typeerrors">TypeErrors</a>
  <ul>
  <li><a href="#typeerror-___-object-is-not-callable" id="toc-typeerror-___-object-is-not-callable" class="nav-link" data-scroll-target="#typeerror-___-object-is-not-callable"><code>TypeError: '___' object is not callable</code></a></li>
  <li><a href="#typeerror-could-not-convert-string-to-a-float" id="toc-typeerror-could-not-convert-string-to-a-float" class="nav-link" data-scroll-target="#typeerror-could-not-convert-string-to-a-float"><code>TypeError: could not convert string to a float</code></a></li>
  <li><a href="#typeerror-could-not-convert-some-string-to-numeric" id="toc-typeerror-could-not-convert-some-string-to-numeric" class="nav-link" data-scroll-target="#typeerror-could-not-convert-some-string-to-numeric"><code>TypeError: Could not convert **some string** to numeric</code></a></li>
  <li><a href="#typeerror-nonetype-object-is-not-subscriptable-attributeerror-nonetype-object-has-no-attribute-shape" id="toc-typeerror-nonetype-object-is-not-subscriptable-attributeerror-nonetype-object-has-no-attribute-shape" class="nav-link" data-scroll-target="#typeerror-nonetype-object-is-not-subscriptable-attributeerror-nonetype-object-has-no-attribute-shape"><code>TypeError: 'NoneType' object is not subscriptable</code> / <code>AttributeError: 'NoneType' object has no attribute 'shape'</code></a></li>
  <li><a href="#typeerror-intfloat-object-is-not-subscriptable" id="toc-typeerror-intfloat-object-is-not-subscriptable" class="nav-link" data-scroll-target="#typeerror-intfloat-object-is-not-subscriptable"><code>TypeError: 'int'</code>/<code>'float' object is not subscriptable</code></a></li>
  </ul></li>
  <li><a href="#indexerrors" id="toc-indexerrors" class="nav-link" data-scroll-target="#indexerrors">IndexErrors</a>
  <ul>
  <li><a href="#indexerror-invalid-index-to-scalar-variable." id="toc-indexerror-invalid-index-to-scalar-variable." class="nav-link" data-scroll-target="#indexerror-invalid-index-to-scalar-variable."><code>IndexError: invalid index to scalar variable.</code></a></li>
  <li><a href="#indexerror-index-_-is-out-of-bounds-for-axis-_-with-size-_" id="toc-indexerror-index-_-is-out-of-bounds-for-axis-_-with-size-_" class="nav-link" data-scroll-target="#indexerror-index-_-is-out-of-bounds-for-axis-_-with-size-_"><code>IndexError: index _ is out of bounds for axis _ with size _</code></a></li>
  </ul></li>
  <li><a href="#valueerrors" id="toc-valueerrors" class="nav-link" data-scroll-target="#valueerrors">ValueErrors</a>
  <ul>
  <li><a href="#valueerror-truth-value-of-a-series-is-ambiguous" id="toc-valueerror-truth-value-of-a-series-is-ambiguous" class="nav-link" data-scroll-target="#valueerror-truth-value-of-a-series-is-ambiguous"><code>ValueError: Truth value of a Series is ambiguous</code></a></li>
  <li><a href="#valueerror-can-only-compare-identically-labeled-series-objects" id="toc-valueerror-can-only-compare-identically-labeled-series-objects" class="nav-link" data-scroll-target="#valueerror-can-only-compare-identically-labeled-series-objects"><code>ValueError: Can only compare identically-labeled Series objects</code></a></li>
  <li><a href="#valueerror--1-is-not-in-range-keyerror--1" id="toc-valueerror--1-is-not-in-range-keyerror--1" class="nav-link" data-scroll-target="#valueerror--1-is-not-in-range-keyerror--1"><code>ValueError: -1 is not in range</code> / <code>KeyError: -1</code></a></li>
  </ul></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Pandas</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="understanding-pandas-errors" class="level2">
<h2 class="anchored" data-anchor-id="understanding-pandas-errors">Understanding <code>pandas</code> errors</h2>
<p><code>pandas</code> errors can look red, scary, and very long. Fortunately, we don’t need to understand the entire thing! The most important parts of an error message are at the <strong>top</strong>, which tells you which line of code is causing the issue, and at the <strong>bottom</strong>, which tells you exactly what the error message is.</p>
<center>
<img src="pandas_error.png" width="700">
</center>
<p>This note is (mostly) structured around the error messages that show up at the bottom.</p>
</section>
<section id="my-code-is-taking-a-really-long-time-to-run" class="level2">
<h2 class="anchored" data-anchor-id="my-code-is-taking-a-really-long-time-to-run">My code is taking a really long time to run</h2>
<p>It is normal for a cell to take a few seconds – sometimes a few minutes – to run. If it’s is taking too long, however, you have several options:</p>
<ol type="1">
<li>Try restarting the kernel. Sometimes, Datahub glitches or lags, causing the code to run slower than expected. Restarting the kernel should fix this problem, but if the cell is still taking a while to run, it is likely a problem with your code.</li>
<li>Scrutinize your code. Am I using too many for loops? Is there a repeated operation that I can substitute with a <code>pandas</code> function?</li>
</ol>
</section>
<section id="why-is-it-generally-better-avoid-using-loops-or-list-comprehensions-when-possible" class="level2">
<h2 class="anchored" data-anchor-id="why-is-it-generally-better-avoid-using-loops-or-list-comprehensions-when-possible">Why is it generally better avoid using loops or list comprehensions when possible?</h2>
<p>In one word, performance. <code>NumPy</code> and other <code>pandas</code> functions are optimized to handle large amounts of data in an efficient manner. Even for simple operations, like the elementwise addition of two arrays, <code>NumPy</code> arrays are much faster and scale better (feel free to experiment with this yourself using <code>%%time</code>). This is why we encourage you to <strong>vectorize</strong> your code and use in-built <code>NumPy</code> functions where possible.</p>
</section>
<section id="keyerrors" class="level1">
<h1>KeyErrors</h1>
<section id="keyerror-column_name" class="level2">
<h2 class="anchored" data-anchor-id="keyerror-column_name"><code>KeyError: 'column_name'</code></h2>
<p>This error usually happens when we have a <code>DataFame</code> called <code>df</code>, and we’re trying to do an operation on the column <code>'column_name'</code>. This <code>KeyError</code> means that <code>df</code> does not have a column called <code>'column_name'</code>.</p>
<p>If you encounter this error, double check that you’re operating on the right column. It might be a good idea to add a cell to display your <code>DataFrame</code>. You could also call <code>df.columns</code> to list all the columns in <code>df</code>.</p>
</section>
</section>
<section id="typeerrors" class="level1">
<h1>TypeErrors</h1>
<section id="typeerror-___-object-is-not-callable" class="level2">
<h2 class="anchored" data-anchor-id="typeerror-___-object-is-not-callable"><code>TypeError: '___' object is not callable</code></h2>
<p>This often happens when you use a default keyword (like <code>str</code>, <code>list</code>, <code>range</code> <code>sum</code>, or <code>max</code>) as a variable name, for instance</p>
<pre><code>sum = 1 + 2 + 3</code></pre>
<p>These errors can be tricky because they don’t error on their own but cause problems when we try to use the name <code>sum</code> (for example) later on in the notebook.</p>
<p>To fix the issue, identify any such lines of code, change your variable names to be something more informative, and restart your notebook.</p>
<p>Python keywords like <code>str</code> and <code>list</code> appear in green text, so be on the lookout if any of your variable names appear in green!</p>
</section>
<section id="typeerror-could-not-convert-string-to-a-float" class="level2">
<h2 class="anchored" data-anchor-id="typeerror-could-not-convert-string-to-a-float"><code>TypeError: could not convert string to a float</code></h2>
<p>This error often occurs when we try to do math operations (ie. <code>sum</code>, <code>average</code>, <code>min</code>, <code>max</code>) on a <code>DataFrame</code> column or <code>Series</code> that contains strings instead of numbers (note that we can do math operations with booleans; Python treats <code>True</code> as 1 and <code>False</code> as 0). Double check that the column you’re interested in is a numerical type (<code>int</code>, <code>float</code>, or <code>double</code>). If it looks like a number, but you’re still getting this error, you can use <code>.astype(...)</code> (<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.astype.html">documentation</a>) to change the datatype of a <code>DataFrame</code> or <code>Series</code>.</p>
</section>
<section id="typeerror-could-not-convert-some-string-to-numeric" class="level2">
<h2 class="anchored" data-anchor-id="typeerror-could-not-convert-some-string-to-numeric"><code>TypeError: Could not convert **some string** to numeric</code></h2>
<p>Related to the above (but distinct), you may run into this error when performing a numeric aggregation function (like mean, sum, functions taking integer arguments) after doing a <code>groupby</code> operation on a <code>DataFrame</code> with non-numeric columns. Working with the <code>elections</code> dataset for example, <code>elections.groupby('Year').agg('mean')</code> would error because <code>pandas</code> cannot compute the mean of the names of Presidents. There are two ways to get around this:</p>
<ol type="1">
<li>Select only the numeric columns you are interested in before applying the aggregation function. In the above case, both <code>elections['Popular vote'].groupby ...</code> or <code>elections.groupby('Year')['Popular Vote']</code> would work.</li>
<li>Setting the <code>numeric_only</code> argument to <code>True</code> in the <code>.agg</code> call, thereby applying the aggregation function only to numeric columns.</li>
</ol>
</section>
<section id="typeerror-nonetype-object-is-not-subscriptable-attributeerror-nonetype-object-has-no-attribute-shape" class="level2">
<h2 class="anchored" data-anchor-id="typeerror-nonetype-object-is-not-subscriptable-attributeerror-nonetype-object-has-no-attribute-shape"><code>TypeError: 'NoneType' object is not subscriptable</code> / <code>AttributeError: 'NoneType' object has no attribute 'shape'</code></h2>
<p>This usually occurs as you assign a <code>None</code> value to a variable, and then try to either index into or access some attribute of that variable. Assigning <code>None</code> usually happens accidentally, sometimes due to code like <code>some_array = some_array.append(element)</code> or other functions that mutate the variable directly and return <code>None</code>. In contrast, note that <code>np.append</code> is not an in-place operation and so the syntax is similar to the above example.</p>
</section>
<section id="typeerror-intfloat-object-is-not-subscriptable" class="level2">
<h2 class="anchored" data-anchor-id="typeerror-intfloat-object-is-not-subscriptable"><code>TypeError: 'int'</code>/<code>'float' object is not subscriptable</code></h2>
<p>This occurs when you try and index into an integer or other numeric <code>Python</code> data type. It can be confusing to debug amidst a muddle of code, but using the error message you can identify which variable is causing this error. Using <code>type(var_name)</code> to check the data type of the variable in question can be a good starting point.</p>
</section>
</section>
<section id="indexerrors" class="level1">
<h1>IndexErrors</h1>
<section id="indexerror-invalid-index-to-scalar-variable." class="level2">
<h2 class="anchored" data-anchor-id="indexerror-invalid-index-to-scalar-variable."><code>IndexError: invalid index to scalar variable.</code></h2>
<p>This error is similar to the last <code>TypeError</code> in the previous section. However, it is slightly different in that scalar variables come up in the context of <code>NumPy</code> data types which have slightly different attributes. For a concrete example, if you defined <code>numpy_arr = np.array([1])</code> and then indexed into it twice (<code>numpy_arr[0][0]</code>), you would get the above error. Unlike a Python integer whose type is <code>int</code>, <code>type(numpy_arr[0])</code> returns <code>numpy.int64</code>. Additionally, you can check the data type by accessing the <code>.dtype</code> attribute of <code>NumPy</code> scalar variable.</p>
</section>
<section id="indexerror-index-_-is-out-of-bounds-for-axis-_-with-size-_" class="level2">
<h2 class="anchored" data-anchor-id="indexerror-index-_-is-out-of-bounds-for-axis-_-with-size-_"><code>IndexError: index _ is out of bounds for axis _ with size _</code></h2>
<p>This error usually happens when you try to index a value that’s greater than the size of the array/list/<code>DataFrame</code>/<code>Series</code>. For example</p>
<pre><code>some_list = [2, 4, 6, 8]</code></pre>
<p><code>some_list</code> has a length of 4. If I try <code>some_list[6]</code>, this will error because index 6 is greater than the length of the array. Note that <code>some_list[4]</code> will also cause an <code>IndexError</code> because Python and <code>pandas</code> uses zero indexing, which means that the first element has index 0, the second element has index 1, etc. <code>some_list[4]</code> would grab the fifth element, which is impossible when the list only has 4 elements.</p>
</section>
</section>
<section id="valueerrors" class="level1">
<h1>ValueErrors</h1>
<section id="valueerror-truth-value-of-a-series-is-ambiguous" class="level2">
<h2 class="anchored" data-anchor-id="valueerror-truth-value-of-a-series-is-ambiguous"><code>ValueError: Truth value of a Series is ambiguous</code></h2>
<p>This error occurs when you apply Python logical operators (<code>or</code>, <code>and</code>, <code>not</code>) to <code>NumPy</code> arrays or <code>Series</code> objects. The fix is to use <code>|</code>, <code>&amp;</code>, <code>~</code> bitwise operators instead that allow for elementwise comparisons between entries.</p>
</section>
<section id="valueerror-can-only-compare-identically-labeled-series-objects" class="level2">
<h2 class="anchored" data-anchor-id="valueerror-can-only-compare-identically-labeled-series-objects"><code>ValueError: Can only compare identically-labeled Series objects</code></h2>
<p>As the message would suggest, this error occurs when comparing two <code>Series</code> objects that have different lengths. You can double check the lengths of the <code>Series</code> using len()</p>
</section>
<section id="valueerror--1-is-not-in-range-keyerror--1" class="level2">
<h2 class="anchored" data-anchor-id="valueerror--1-is-not-in-range-keyerror--1"><code>ValueError: -1 is not in range</code> / <code>KeyError: -1</code></h2>
<p>This error occurs when you try and index into a <code>Series</code> or <code>DataFrame</code> as you would a Python list. Unlike a list where passing an index of -1 gives the last element, <code>pandas</code> interprets <code>df[-1]</code> as an attempt to find the row corresponding to index -1 (that is, <code>df.loc[-1]</code>). If your intention is to pick out the last row in <code>df</code>, consider using integer-position based indexing by doing <code>df.iloc[-1]</code>. In general, to avoid ambiguity in these cases, it is also good practice to write out both the row and column indices you want with <code>df.iloc[-1, :]</code>.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>