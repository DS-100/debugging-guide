<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.545">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>RegEx</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="regex_files/libs/clipboard/clipboard.min.js"></script>
<script src="regex_files/libs/quarto-html/quarto.js"></script>
<script src="regex_files/libs/quarto-html/popper.min.js"></script>
<script src="regex_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="regex_files/libs/quarto-html/anchor.min.js"></script>
<link href="regex_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="regex_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="regex_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="regex_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="regex_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#how-to-interpret-regex101" id="toc-how-to-interpret-regex101" class="nav-link active" data-scroll-target="#how-to-interpret-regex101">How to Interpret RegEx101</a>
  <ul>
  <li><a href="#example-1-basic" id="toc-example-1-basic" class="nav-link" data-scroll-target="#example-1-basic">Example 1: Basic</a></li>
  <li><a href="#example-2-greedy" id="toc-example-2-greedy" class="nav-link" data-scroll-target="#example-2-greedy">Example 2: Greedy</a></li>
  <li><a href="#example-3-capturing-groups" id="toc-example-3-capturing-groups" class="nav-link" data-scroll-target="#example-3-capturing-groups">Example 3: Capturing Groups</a>
  <ul>
  <li><a href="#how-do-i-access-captured-groups" id="toc-how-do-i-access-captured-groups" class="nav-link" data-scroll-target="#how-do-i-access-captured-groups">How do I access captured groups?</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#regex-misconceptions-general-errors" id="toc-regex-misconceptions-general-errors" class="nav-link" data-scroll-target="#regex-misconceptions-general-errors">RegEx Misconceptions &amp; General Errors</a>
  <ul>
  <li><a href="#im-certain-my-regex-pattern-in-.str.replace-is-correct-but-im-not-passing-the-grader-check." id="toc-im-certain-my-regex-pattern-in-.str.replace-is-correct-but-im-not-passing-the-grader-check." class="nav-link" data-scroll-target="#im-certain-my-regex-pattern-in-.str.replace-is-correct-but-im-not-passing-the-grader-check.">I’m certain my RegEx pattern in .str.replace is correct, but I’m not passing the grader check.</a></li>
  <li><a href="#value-error-pattern-contains-no-capture-groups" id="toc-value-error-pattern-contains-no-capture-groups" class="nav-link" data-scroll-target="#value-error-pattern-contains-no-capture-groups"><code>Value Error: pattern contains no capture groups</code></a></li>
  <li><a href="#when-do-i-need-to-escape-special-characters" id="toc-when-do-i-need-to-escape-special-characters" class="nav-link" data-scroll-target="#when-do-i-need-to-escape-special-characters">When do I need to escape special characters?</a></li>
  <li><a href="#three-uses-of" id="toc-three-uses-of" class="nav-link" data-scroll-target="#three-uses-of">Three uses of ‘^’</a></li>
  <li><a href="#whats-the-difference-between-all-the-re-functions" id="toc-whats-the-difference-between-all-the-re-functions" class="nav-link" data-scroll-target="#whats-the-difference-between-all-the-re-functions">What’s the difference between all the <code>re</code> functions?</a></li>
  <li><a href="#whats-the-difference-between-re-functions-and-pd.series.str-functions" id="toc-whats-the-difference-between-re-functions-and-pd.series.str-functions" class="nav-link" data-scroll-target="#whats-the-difference-between-re-functions-and-pd.series.str-functions">What’s the difference between <code>re</code> functions and <code>pd.Series.str</code> functions?</a></li>
  </ul></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">RegEx</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>RegEx syntax can be incredibly confusing, so we highly encourage to use sources like the Data 100 Exam reference sheet, which you can find in the “Exam Resources” section in our <a href="https://ds100.org/sp24/resources/">Resources page</a> or websites like <a href="https://regex101.com/">regex101.com</a> to help build your understanding.</p>
<section id="how-to-interpret-regex101" class="level2">
<h2 class="anchored" data-anchor-id="how-to-interpret-regex101">How to Interpret RegEx101</h2>
<p>c is a great tool that helps you visually interact with RegEx patterns. Let’s take a look at its components with a simple example:</p>
<section id="example-1-basic" class="level3">
<h3 class="anchored" data-anchor-id="example-1-basic">Example 1: Basic</h3>
<center>
<img src="images/basic.png" width="800">
</center>
<p><br></p>
<ol type="1">
<li><strong>Regular Expression</strong>: This is where the RegEx expression goes. For this example, our pattern is <code>Data 100</code>. In <code>python</code>, we denote it as a string <code>r"Data 100"</code> with the prefix <code>r</code> to indicate that this is a indeed RegEx expression, not a normal <code>python</code> string. Using regex101, however, we don’t need <code>r"..."</code>, just the pattern itself.</li>
<li><strong>Explanation</strong>: This portion of the website explains each component of the pattern above. Since it does not contain any special characters, <code>Data 100</code> will match any portion of a string containing <code>Data 100</code>.</li>
<li><strong>Test String</strong>: This is where you can try out different inputs and see if they match the RegEx pattern. Of the 4 example sentences, we see that only the first sentence contains characters that match the pattern, highlighted in blue. (Note that while sentence 3 does contain <code>data 100</code>, RegEx is sensitive to capitalization. <code>d</code> and <code>D</code> are different characters)</li>
<li><strong>Match Information</strong>: Each match between the RegEx expression and test strings are shown here.</li>
</ol>
</section>
<section id="example-2-greedy" class="level3">
<h3 class="anchored" data-anchor-id="example-2-greedy">Example 2: Greedy</h3>
<p>For this example, let’s replace the <code>100</code> in our original expression with <code>\d*</code> so that our pattern is <code>Data \d*</code></p>
<center>
<img src="images/greedy.png" width="800">
</center>
<p><br></p>
<p><code>\d</code> and <code>*</code> are both special operators, and the explanation on the top right (boxed in red) tells us what they do:</p>
<ul>
<li><code>\d</code> matches digits, or any number between 0 and 9. It’s equlivalent to <code>[0-9]</code>.</li>
<li><code>*</code> matches the previous token <span class="math inline">\(\geq 0\)</span> times. It is a <em>greedy operation</em>, meaning it will match as many characters as possible.</li>
</ul>
<p>Altogether, the expression <code>\d*</code> will match any digit zero or more times. Look at each match under “Match Information”. Can you see why they align with <code>Data \d*</code>?</p>
</section>
<section id="example-3-capturing-groups" class="level3">
<h3 class="anchored" data-anchor-id="example-3-capturing-groups">Example 3: Capturing Groups</h3>
<p>Let’s say we’re given a body of text with dates formatted as <code>DD/MM/YYY</code> (ie. 04/Jan/2014), and we’re interested in extracting the dates. An expression like <code>r"\d+\/\w+\/\d+"</code> would match any string with the <code>DD/MM/YYY</code> format:</p>
<ul>
<li>the first <code>\d+</code> matches <code>DD</code> patterns (ie. <code>04</code>)</li>
<li><code>\/</code> matches the <code>/</code> separator. Since <code>/</code> is a special operator in RegEx, we need to escape it with <code>\</code> to get the literal character.</li>
<li><code>\w+</code> in the middle matches <code>MM</code> patterns (ie. <code>Jan</code>)</li>
<li>lastly, <code>\d+</code> matches <code>YYY</code> patterns (ie. <code>2014</code>)</li>
</ul>
<p>That’s great! This pattern will match the entirety of <code>DD/MM/YYY</code>, but what if we want to access <code>DD</code> individually? What about <code>YYYY</code>? This is where <strong>capturing groups</strong> come in handy. Capturing groups are RegEx expressions surrounded by parenthesis <code>()</code> that are used to remember the text they match so that it can be referenced later. Putting capturing groups around <code>\d+</code> and <code>\w+</code> to get <code>r"(\d+)\/(\w+)\/(\d+)"</code>gives us the following:</p>
<center>
<img src="images/capturing_groups.png" width="800">
</center>
<ul>
<li>The “Explanation” section now shows an explanation for each of the 3 capturing groups.</li>
<li>In our test strings, the portion matching the RegEx expression is highlighted in blue per usual. Additionally, each capturing group is highlighted in it’s own color: green, orange, and purple.</li>
<li>These colored highlights correspond to their match/group under “Match Information”. “Match #” (light blue) shows the entire portion that matches the expression while “Group #” shows the match per group.</li>
</ul>
<section id="how-do-i-access-captured-groups" class="level4">
<h4 class="anchored" data-anchor-id="how-do-i-access-captured-groups">How do I access captured groups?</h4>
<p>To access each group, we use the following syntax:</p>
<pre><code>target_string = "Today's date is 01/April/2024."
result = re.search(r"(\d+)\/(\w+)\/(\d+)", target_string)

result # re.Match object
result.groups() # ('01', 'April', '2024')
result.group(0) # 01/April/2024
result.group(1) # 01
result.group(2) # April
result.group(3) # 2024</code></pre>
</section>
</section>
</section>
<section id="regex-misconceptions-general-errors" class="level2">
<h2 class="anchored" data-anchor-id="regex-misconceptions-general-errors">RegEx Misconceptions &amp; General Errors</h2>
<section id="im-certain-my-regex-pattern-in-.str.replace-is-correct-but-im-not-passing-the-grader-check." class="level3">
<h3 class="anchored" data-anchor-id="im-certain-my-regex-pattern-in-.str.replace-is-correct-but-im-not-passing-the-grader-check.">I’m certain my RegEx pattern in .str.replace is correct, but I’m not passing the grader check.</h3>
<p>Here’s the skeleton from the exam reference sheet:</p>
<p><code>s.str.replace(pat, repl, regex=False)</code></p>
<p>Notice how the <code>regex=</code> argument is automatically set to <code>False</code>, causing <code>pandas</code> to treat <code>pat</code> like a normal <code>python</code> string. Make sure to set <code>regex=True</code>.</p>
</section>
<section id="value-error-pattern-contains-no-capture-groups" class="level3">
<h3 class="anchored" data-anchor-id="value-error-pattern-contains-no-capture-groups"><code>Value Error: pattern contains no capture groups</code></h3>
<p>These errors usually occur when using <code>s.str.extract</code> or <code>s.str.extractall</code>. Read more about in course notes: https://ds100.org/course-notes/regex/regex.html#extraction-with-pandas. This error means that your RegEx pattern does not match anything in the given <code>Series</code> of strings. To debug this, try putting your pattern into <code>s.str.extract</code> and <code>s.str.extractall</code> and use example strings from the Series as test cases.</p>
</section>
<section id="when-do-i-need-to-escape-special-characters" class="level3">
<h3 class="anchored" data-anchor-id="when-do-i-need-to-escape-special-characters">When do I need to escape special characters?</h3>
<p>The special characters in RegEx are: \texttt{. ^ $ * + ? ] [ &nbsp;| ( ) { } } If you want to match exactly those characters in a RegEx expression, you need to “escape” them by preceding them with a backslash . However, the rules around this can change in the context of character classes.</p>
<p>For example, the pattern r”[.]” matches “.”, the literal period. In this context, it is not treated as a special character. The hyphen, while not included in the list of special characters, also changes its behavior depending on its position in a character class. It can be used to specify a range of characters (e.g.&nbsp;r”[a-z0-9]“) based on their unicode values, or match a literal ‘-’ if it does not have two adjacent characters (e.g.&nbsp;r”[-09]” matches ‘-’, ‘0’, ‘9’).</p>
<p>Finally, it’s generally good practice to escape both single and double quotes for greater readability. Technically, patterns like r”‘(.*)’” and r‘“(.*)”’ do work, but you can already see how confusing it is to decipher what’s going on.</p>
</section>
<section id="three-uses-of" class="level3">
<h3 class="anchored" data-anchor-id="three-uses-of">Three uses of ‘^’</h3>
<p>The ‘^’ character can be a tricky to wrap your head around given how it’s function changes depending on the context: If used at the start of a pattern, like in r“^”, it means that a lowercase letter must begin the string in order for a match to occur. If included at the start of a character class, like in r“[^abc]”, it negates all the characters in that class and will match with any other character – in the above example, any character that is not ‘a’, ‘b’, ‘c’. Finally, if escaped as in r”^” it is treated as a literal and will match any instance of ‘^’.</p>
</section>
<section id="whats-the-difference-between-all-the-re-functions" class="level3">
<h3 class="anchored" data-anchor-id="whats-the-difference-between-all-the-re-functions">What’s the difference between all the <code>re</code> functions?</h3>
<p>The exam reference sheets give a few <code>re</code> functions, but how can you determine which one to use?</p>
<center>
<img src="images/ref_sheet_re_methods.png" width="800">
</center>
<ul>
<li>re.match and re.search only return one instance of a match between string and pattern (or None if there’s no match)</li>
<li>re.match only considers characters at the beginning of a string</li>
<li>re.search considers characters anywhere in the string</li>
</ul>
<p>Example:</p>
<pre><code>pattern = r”Data 100” 
example1 = “Data 100 is the best!” 
example2 = “I love Data 100!” 
re.match(pattern, example1).group(0) # matches “Data 100” 
re.match(pattern, example2) # does not match “Data 100” because it’s not at the beginning of a string; returns None
re.search(pattern, example1).group(0) # matches “Data 100” 
re.search(pattern, example2).group(0) # also matches “Data 100” </code></pre>
<p>If, instead, you’re interested in finding all matches between the given string and pattern, re.findall will find them all, returning the matches in a list</p>
<pre><code>re.findall(r'\d+', 'Data 100, Data 8, Data 101') # returns a list of strings: ['100', '8', '101']
re.findall(r'\d+', 'Data science is great')  # no matches found, returns empty list: []
re.sub will find them all and replace it with a string of your choosing
re.sub(r'\d+', ‘panda’, 'Data 100, Data 8, Data 101') # returns 'Data panda, Data panda, Data panda'
re.sub(r'\d+', ‘panda’, 'Data science is great')  # no matches found, returns the original string “Data science is great” </code></pre>
</section>
<section id="whats-the-difference-between-re-functions-and-pd.series.str-functions" class="level3">
<h3 class="anchored" data-anchor-id="whats-the-difference-between-re-functions-and-pd.series.str-functions">What’s the difference between <code>re</code> functions and <code>pd.Series.str</code> functions?</h3>
<p>Generally, all the <code>pd.Series.str</code> functions are used when you want to apply a Python or RegEx string function to a <em>Series of strings</em>. In contrast, <code>re</code> functions are applied to string objects. The reference sheet gives a great overview of the different use cases of each of the <code>pd.Series.str</code> functions.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>